授業のメモ
第3回
エレベーターピッチ
最後は10分で素晴らしい授業を！

CALL命令
CALL A
A:アドレス、名前、オブジェクトの名前、、、

0x1234 アドレス：アドレスだとアドレスが変わる場合がある
"f" 名前：マイグレーションするときに有利
object 3 番号：実行するときは番号のマッピングする方が良い
「ポストスクリプト」
－－－スタックポインタとプログラムカウンタとベースポインタとは一体
－－－コストがかかるとは？？？

＜配列を扱おう！＞
push 0
set sum
push 0
set_local "i"
malloc 400
set_local "ary"
get_local "i"
mul "4"
get_local "i"
get_local "ary"
aset
jump_if
…
free

メソッド呼び出し
―――命令を作らない代わりにメソッドを呼び出す？？？

人間がFreeするの大変だよね
―――ガーベッジコレクション：使われていないメモリが分かればそのメモリを消せる
Mark & Sweep 

Pythonだと…
reference count

他にも
Copy GC

第5回6/30
高速化の話
レポートかくとき
論文・書籍あったら参考文献として入れてね
０．繰り返しによるフィボナッチ数の計算
fib(n)のオーダー　log(n)
１．再帰によるフィボナッチ数列の計算（ベース）
→これを速くする（計算量オーダー）
元のプログラミング言語を想定（Javaにしよう！）

コンパイル→命令列を想定して、VMを動かす命令をつくる
→どう動かすか

（２．再帰よりももっと面白いプログラム）

最後のレポート
すごさ：ここがすごい！というところ
ーーーーーーーーーーーーーーーーーーー
高速化（Performance）
アルゴリズムを変える→速さが劇的に変わるかも！？
プログラム変換

getlocalの実装の話
getlocal L1
L1と数字を対応させる、（Python:Dictionary, Java:Map）
配列にするMap vs Array
Arrayではなくて全部Stackに積む
・スタックキャッシング
・メソッドディスパッチ
・ダイレクトスレッデッドコード
・ジャストインタイムコンパイル
・スーパーインストラクション
・peephole opt
・コンスタントフォールディング

